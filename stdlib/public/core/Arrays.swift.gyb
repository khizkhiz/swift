//===--- Arrays.swift.gyb -------------------------------------*- swift -*-===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2014 - 2015 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See http://swift.org/LICENSE.txt for license information
// See http://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//
//
//  Three generic, mutable array-like types with value semantics.
//
//  - `ContiguousArray<Element>` is a fast, contiguous array of `Element` with
//    a known backing store.
//
//  - `ArraySlice<Element>` presents an arbitrary subsequence of some
//    contiguous sequence of `Element`s.
//
//  - `Array<Element>` is like `ContiguousArray<Element>` when `Element` is not
//    a reference type or an Objective-C existential.  Otherwise, it may use
//    an `NSArray` bridged from Cocoa for storage.
//
//===----------------------------------------------------------------------===//

/// This type is used as a result of the _checkSubscript call to associate the
/// call with the array access call it guards.
public struct _DependenceToken {}

%{
  arrayTypes = [
    ('ContiguousArray', 'a ContiguousArray'),
    ('ArraySlice', 'an `ArraySlice`'),
    ('Array', 'an `Array`'),
  ]
}%

% for (Self, a_Self) in arrayTypes:

%{
if True:
    O1 = ("O(1) unless `self`'s storage is"
       + ' shared with another live array; O(`length`) '
       + ('if `self` does not wrap a bridged `NSArray`; '
       + 'otherwise the efficiency is unspecified.'
         if Self == 'Array' else 'otherwise.'))

    contiguousCaveat = (
      ' If no such storage exists, it is first created.' if Self == 'Array'
      else '')

    if Self == 'ContiguousArray':
      SelfDocComment = """\
/// A fast, contiguously-stored array of `Element`.
///
/// Efficiency is equivalent to that of `Array`, unless `Element` is a
/// `class` or `@objc` `protocol` type, in which case using
/// `ContiguousArray` may be more efficient.  Note, however, that
/// `ContiguousArray` does not bridge to Objective-C.  See `Array`,
/// with which `ContiguousArray` shares most properties, for more
/// detail."""
    elif Self == 'ArraySlice':
      SelfDocComment = """\
/// The `Array`-like type that represents a sub-sequence of any
/// `Array`, `ContiguousArray`, or other `ArraySlice`.
///
/// `ArraySlice` always uses contiguous storage and does not bridge to
/// Objective-C.
///
/// - Warning: Long-term storage of `ArraySlice` instances is discouraged.
///
/// Because a `ArraySlice` presents a *view* onto the storage of some
/// larger array even after the original array's lifetime ends,
/// storing the slice may prolong the lifetime of elements that are
/// no longer accessible, which can manifest as apparent memory and
/// object leakage.  To prevent this effect, use `ArraySlice` only for
/// transient computation."""
    elif Self == 'Array':
      SelfDocComment = '''\
/// `Array` is an efficient, tail-growable random-access
/// collection of arbitrary elements.
///
/// Common Properties of Array Types
/// ================================
///
/// The information in this section applies to all three of Swift's
/// array types, `Array<Element>`, `ContiguousArray<Element>`, and
/// `ArraySlice<Element>`.  When you read the word "array" here in
/// a normal typeface, it applies to all three of them.
///
/// Value Semantics
/// ---------------
///
/// Each array variable, `let` binding, or stored property has an
/// independent value that includes the values of all of its elements.
/// Therefore, mutations to the array are not observable through its
/// copies:
///
///     var a = [1, 2, 3]
///     var b = a
///     b[0] = 4
///     print("a=\(a), b=\(b)")     // a=[1, 2, 3], b=[4, 2, 3]
///
/// (Of course, if the array stores `class` references, the objects
/// are shared; only the values of the references are independent.)
///
/// Arrays use Copy-on-Write so that their storage and elements are
/// only copied lazily, upon mutation, when more than one array
/// instance is using the same buffer.  Therefore, the first in any
/// sequence of mutating operations may cost `O(N)` time and space,
/// where `N` is the length of the array.
///
/// Growth and Capacity
/// -------------------
///
/// When an array's contiguous storage fills up, new storage must be
/// allocated and elements must be moved to the new storage.  `Array`,
/// `ContiguousArray`, and `ArraySlice` share an exponential growth
/// strategy that makes `append` a constant time operation *when
/// amortized over many invocations*.  In addition to a `length`
/// property, these array types have a `capacity` that reflects their
/// potential to store elements without reallocation, and when you
/// know how many elements you'll store, you can call
/// `reserveCapacity` to preemptively reallocate and prevent
/// intermediate reallocations.
///
/// Objective-C Bridge
/// ==================
///
/// The main distinction between `Array` and the other array types is
/// that it interoperates seamlessly and efficiently with Objective-C.
///
/// `Array<Element>` is considered bridged to Objective-C iff `Element`
/// is bridged to Objective-C.
///
/// When `Element` is a `class` or `@objc` protocol type, `Array` may
/// store its elements in an `NSArray`.  Since any arbitrary subclass
/// of `NSArray` can become an `Array`, there are no guarantees about
/// representation or efficiency in this case (see also
/// `ContiguousArray`).  Since `NSArray` is immutable, it is just as
/// though the storage was shared by some copy: the first in any
/// sequence of mutating operations causes elements to be copied into
/// unique, contiguous storage which may cost `O(N)` time and space,
/// where `N` is the length of the array (or more, if the underlying
/// `NSArray` has unusual performance characteristics).
///
/// Bridging to Objective-C
/// -----------------------
///
/// Any bridged `Array` can be implicitly converted to an `NSArray`.
/// When `Element` is a `class` or `@objc` protocol, bridging takes O(1)
/// time and O(1) space.  Other `Array`s must be bridged
/// element-by-element, allocating a new object for each element, at a
/// cost of at least O(`length`) time and space.
///
/// Bridging from Objective-C
/// -------------------------
///
/// An `NSArray` can be implicitly or explicitly converted to any
/// bridged `Array<Element>`.  This conversion calls `copyWithZone`
/// on the `NSArray`, to ensure it won't be modified, and stores the
/// result in the `Array`.  Type-checking, to ensure the `NSArray`'s
/// elements match or can be bridged to `Element`, is deferred until the
/// first element access.'''
# FIXME: Write about Array up/down-casting.
    else:
      raise AssertionError('Unhandled case: ' + Self)
}%

${SelfDocComment}
public struct ${Self}<Element>
  : Collection, MutableCollection, _DestructorSafeContainer {

%if Self == 'ArraySlice':
  /// The position of the first element in a non-empty collection.
  ///
  /// In an empty collection, `startIndex == endIndex`.
%else:
  /// Always zero, which is the index of the first element when non-empty.
%end
  public var startIndex: Int {
%if Self == 'ArraySlice':
    return _buffer.startIndex
%else:
    return 0
%end
  }

  /// A "past-the-end" element index; the successor of the last valid
  /// subscript argument.
  public var endIndex: Int {
%if Self == 'ArraySlice':
    return _buffer.endIndex
%else:
    return _getLength()
%end
  }

#if _runtime(_ObjC)
  // FIXME: Code is duplicated here between the Objective-C and non-Objective-C
  // runtimes because config blocks can't appear inside a subscript function
  // without causing parse errors. When this is fixed, they should be merged
  // as described in the comment below.
  // rdar://problem/19553956

  /// Access the `index`th element. Reading is O(1).  Writing is
  /// ${O1}.
  public subscript(index: Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be 
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()
      
      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }
    mutableAddressWithPinnedNativeOwner {
      _makeMutableAndUniqueOrPinned() // makes the array native, too
      _checkSubscript_native(index)   
      return (_getElementAddress(index), Builtin.tryPin(_getOwner_native()))
    }
  }
#else
  /// Access the `index`th element. Reading is O(1).  Writing is
  /// ${O1}.
  public subscript(index: Int) -> Element {
    get {
      // This call may be hoisted or eliminated by the optimizer.  If
      // there is an inout violation, this value may be stale so needs to be
      // checked again below.
      let wasNativeTypeChecked = _hoistableIsNativeTypeChecked()

      // Make sure the index is in range and wasNativeTypeChecked is
      // still valid.
      let token = _checkSubscript(
        index, wasNativeTypeChecked: wasNativeTypeChecked)

      return _getElement(
        index, wasNativeTypeChecked: wasNativeTypeChecked,
        matchingSubscriptCheck: token)
    }

    mutableAddressWithPinnedNativeOwner {
      _makeMutableAndUniqueOrPinned()
      _checkSubscript_native(index)
      return (
        _getElementAddress(index),
        Builtin.tryPin(_getOwner_native()))
    }
  }
#endif

  /// Access the contiguous subrange of elements enclosed by `bounds`.
  ///
  /// - Complexity: O(1).
  public subscript(bounds: Range<Int>) -> ArraySlice<Element> {
    get {
      _checkIndex(bounds.startIndex)
      _checkIndex(bounds.endIndex)
      return ArraySlice(_buffer[bounds])
    }
    set(rhs) {
      _checkIndex(bounds.startIndex)
      _checkIndex(bounds.endIndex)
      if self[bounds]._buffer.identity != rhs._buffer.identity {
        self.replaceSubrange(bounds, with: rhs)
      }
    }
  }

  //===--- private --------------------------------------------------------===//

  /// Returns true if the array is native and does not need a deferred
  /// type check.  May be hoisted by the optimizer, which means its
  /// results may be stale by the time they are used if there is an
  /// inout violation in user code.
  @warn_unused_result
  @_semantics("array.props.isNativeTypeChecked")
  public // @testable
  func _hoistableIsNativeTypeChecked() -> Bool {
   return _buffer.arrayPropertyIsNativeTypeChecked
  }

  @warn_unused_result
  @_semantics("array.get_length")
  internal func _getLength() -> Int {
    return _buffer.length
  }
  @warn_unused_result
  @_semantics("array.get_capacity")
  internal func _getCapacity() -> Int {
    return _buffer.capacity
  }

  /// - Requires: The array has a native buffer.
  @warn_unused_result
  @_semantics("array.owner")
  internal func _getOwnerWithSemanticLabel_native() -> Builtin.NativeObject {
    return Builtin.castToNativeObject(_buffer.nativeOwner)
  }

  /// - Requires: The array has a native buffer.
  @warn_unused_result
  @inline(__always)
  internal func _getOwner_native() -> Builtin.NativeObject {
#if _runtime(_ObjC)
    if _isClassOrObjCExistential(Element.self) {
      // We are hiding the access to '_buffer.owner' behind
      // _getOwner() to help the compiler hoist uniqueness checks in
      // the case of class or objective c existential typed array
      // elements. 
      return _getOwnerWithSemanticLabel_native()
    }
#endif
    // In the value typed case the extra call to
    // _getOwnerWithSemanticLabel_native hinders optimization.
    return Builtin.castToNativeObject(_buffer.owner)
  }
  
  // Don't inline copyBuffer - this would inline the copy loop into the current
  // path preventing retains/releases to be matched across that region.
  @inline(never)
  static internal func _copyBuffer(inout buffer: _Buffer) {
    let newBuffer = _ContiguousArrayBuffer<Element>(
      length: buffer.length, minimumCapacity: buffer.length)
    buffer._uninitializedCopy(
      buffer.indices, target: newBuffer.firstElementAddress)
    buffer = _Buffer(newBuffer, shiftedToStartIndex: buffer.startIndex)
  }

  @_semantics("array.make_mutable")
  internal mutating func _makeMutableAndUnique() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {
      ${Self}._copyBuffer(&_buffer)
    }
  }

  @_semantics("array.make_mutable")
  internal mutating func _makeMutableAndUniqueOrPinned() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferencedOrPinned()) {
      ${Self}._copyBuffer(&_buffer)
    }
  }


  /// Check that the given `index` is valid for subscripting, i.e. `0
  /// ≤ index < length`.
  @inline(__always)
  internal func _checkSubscript_native(index: Int) {
% if Self != 'Array':
    _buffer._checkValidSubscript(index)
% else:
    _checkSubscript(index, wasNativeTypeChecked: true)
% end
  }

  /// Check that the given `index` is valid for subscripting, i.e. `0
  /// ≤ index < length`.
  @_semantics("array.check_subscript")
  public // @testable
  func _checkSubscript(
    index: Int, wasNativeTypeChecked: Bool
  ) -> _DependenceToken {
#if _runtime(_ObjC)
% if Self == 'Array':
    _buffer._checkInoutAndNativeTypeCheckedBounds(
      index, wasNativeTypeChecked: wasNativeTypeChecked)
% else:
    _buffer._checkValidSubscript(index)
% end
#else
    _buffer._checkValidSubscript(index)
#endif
    return _DependenceToken()
  }

  /// Check that the given `index` is valid, i.e. `0 ≤ index ≤ length`.
  @_semantics("array.check_index")
  internal func _checkIndex(index: Int) {
    _require(index <= endIndex, "${Self} index out of range")
    _require(index >= startIndex, "Negative ${Self} index is out of range")
  }

  @warn_unused_result
  @_semantics("array.get_element")
  @inline(__always)
  public // @testable
  func _getElement(
    index: Int,
    wasNativeTypeChecked : Bool,
    matchingSubscriptCheck: _DependenceToken
  ) -> Element {
#if ${'_runtime(_ObjC)' if Self == 'Array' else 'false'}
    return _buffer.getElement(index, wasNativeTypeChecked: wasNativeTypeChecked)
#else
    return _buffer.getElement(index)
#endif
  }

  @warn_unused_result
  @_semantics("array.get_element_address")
  internal func _getElementAddress(index: Int) -> UnsafeMutablePointer<Element> {
    return _buffer._unconditionalMutableSubscriptBaseAddress + index
  }

%if Self == 'Array':
#if _runtime(_ObjC)
  public typealias _Buffer = _ArrayBuffer<Element>
#else
  public typealias _Buffer = _ContiguousArrayBuffer<Element>
#endif
%elif Self == 'ArraySlice':
  public typealias _Buffer = _SliceBuffer<Element>
%else:
  public typealias _Buffer = _${Self.strip('_')}Buffer<Element>
%end

  /// Initialization from an existing buffer does not have "array.init"
  /// semantics because the caller may retain an alias to buffer.
  public init(_ _buffer: _Buffer) {
    self._buffer = _buffer
  }

  public var _buffer: _Buffer
}

extension ${Self} : ArrayLiteralConvertible {
%if Self == 'Array':
  // Optimized implementation for Array
  /// Create an instance containing `elements`.
  public init(arrayLiteral elements: Element...) {
    self = elements
  }
%else:
  /// Create an instance containing `elements`.
  public init(arrayLiteral elements: Element...) {
    self.init(_extractOrCopyToNativeArrayBuffer(elements._buffer))
  }
%end
}

%if Self == 'Array':

// Referenced by the compiler to allocate array literals.
//
/// Returns an Array of `_length` uninitialized elements using the
/// given `storage`, and a pointer to uninitialized memory for the
/// first element.
///
/// - Requires: `storage` is _ContiguousArrayStorage.
@warn_unused_result
@inline(__always)
public func _allocateUninitializedArray<Element>(_length: Builtin.Word)
    -> (Array<Element>, Builtin.RawPointer) {
  let length = Int(_length)
  if length > 0 {
    // Doing the actual buffer allocation outside of the array.uninitialized
    // semantics function enables stack propagation of the buffer.
    let bufferObject = ManagedBufferPointer<_ArrayBody, Element>(
      _uncheckedBufferClass: _ContiguousArrayStorage<Element>.self,
      minimumCapacity: length)

    let (array, ptr) = Array<Element>._adoptStorage(
      bufferObject.buffer, length: length)
    return (array, ptr._rawValue)
  }
  // For an empty array no buffer allocation is needed.
  let (array, ptr) = Array<Element>._allocateUninitialized(length)
  return (array, ptr._rawValue)
}

// Referenced by the compiler to deallocate array literals on the
// error path.
@warn_unused_result
@_semantics("array.dealloc_uninitialized")
public func _deallocateUninitialized${Self}<Element>(
  array: ${Self}<Element>
) {
  var array = array
  array._deallocateUninitialized()
}
%end

extension ${Self} : _ArrayProtocol {
  /// Construct an empty ${Self}.
  @_semantics("array.init")
  public init() {
    _buffer = _Buffer()
  }

  /// Construct from an arbitrary sequence of `Element`s.
  public init<
    S: Sequence where S.Iterator.Element == _Buffer.Element
  >(_ s: S) {
    self = ${Self}(_Buffer(s._copyToNativeArrayBuffer(),
      shiftedToStartIndex: 0))
  }

  /// Construct a ${Self} of `length` elements, each initialized to
  /// `repeatedValue`.
  @_semantics("array.init")
  public init(repeating repeatedValue: Element, length: Int) {
    var p: UnsafeMutablePointer<Element>
    (self, p) = ${Self}._allocateUninitialized(length)
    for _ in 0..<length {
      p.initializeMemory(repeatedValue)
      p += 1
    }
  }

  @inline(never)
  internal static func _allocateBufferUninitialized(length: Int) -> _Buffer {
    let newBuffer = _ContiguousArrayBuffer<Element>(
      length: 0, minimumCapacity: length)
    return _Buffer(newBuffer, shiftedToStartIndex: 0)
  }

  /// Construct a ${Self} of `length` uninitialized elements.
  internal init(_uninitializedLength length: Int) {
    _require(length >= 0, "Can't construct ${Self} with length < 0")
    // Note: Sinking this constructor into an else branch below causes an extra
    // Retain/Release.
    _buffer = _Buffer()
    if length > 0 {
      // Creating a buffer instead of calling reserveCapacity saves doing an
      // unnecessary uniqueness check. We disable inlining here to curb code
      // growth.
      _buffer = ${Self}._allocateBufferUninitialized(length)
    }
    _buffer.length = length
  }

  /// Entry point for `Array` literal construction; builds and returns
  /// a ${Self} of `length` uninitialized elements.
  @warn_unused_result
  @_semantics("array.uninitialized")
  internal static func _allocateUninitialized(
    length: Int
  ) -> (${Self}, UnsafeMutablePointer<Element>) {
    let result = ${Self}(_uninitializedLength: length)
    return (result, result._buffer.firstElementAddress)
  }

%if Self == 'Array':

  /// Returns an Array of `length` uninitialized elements using the
  /// given `storage`, and a pointer to uninitialized memory for the
  /// first element.
  ///
  /// - Requires: `storage is _ContiguousArrayStorage`.
  @warn_unused_result
  @_semantics("array.uninitialized")
  internal static func _adoptStorage(
    storage: AnyObject, length: Int
  ) -> (Array, UnsafeMutablePointer<Element>) {
    
    _sanityCheck(
      storage is _ContiguousArrayStorage<Element>, "Invalid array storage type")
    
    let innerBuffer = _ContiguousArrayBuffer<Element>(
      length: length, storage: unsafeDowncast(storage))
    
    return (
      Array(_Buffer(innerBuffer, shiftedToStartIndex: 0)),
      innerBuffer.firstElementAddress)
  }

  /// Entry point for aborting literal construction: deallocates
  /// a ${Self} containing only uninitialized elements.
  internal mutating func _deallocateUninitialized() {
    // Set the length to zero and just release as normal.
    // Somewhat of a hack.
    _buffer.length = 0
  }
%end

  /// The number of elements the ${Self} stores.
  public var length: Int {
    return _getLength()
  }

  /// The number of elements the `${Self}` can store without reallocation.
  public var capacity: Int {
    return _getCapacity()
  }

  /// An object that guarantees the lifetime of this array's elements.
  public // @testable
  var _owner: AnyObject? {
    return _buffer.owner
  }

  /// If the elements are stored contiguously, a pointer to the first
  /// element. Otherwise, `nil`.
  public var _baseAddressIfContiguous: UnsafeMutablePointer<Element> {
    return _buffer.firstElementAddress
  }

%if Self != 'Array': # // Array does not necessarily have contiguous storage
  internal var _baseAddress: UnsafeMutablePointer<Element> {
    return _buffer.firstElementAddress
  }
%end
  //===--- basic mutations ------------------------------------------------===//


  /// Reserve enough space to store `minimumCapacity` elements.
  ///
  /// - Postcondition: `capacity >= minimumCapacity` and the array has
  ///   contiguous storage whose elements can be replaced in O(1).
  ///
  /// - Complexity: O(`self.length`).
  @_semantics("array.mutate_unknown")
  public mutating func reserveCapacity(minimumCapacity: Int) {
    if _buffer.requestUniqueMutableBackingBuffer(minimumCapacity) == nil {

      let newBuffer = _ContiguousArrayBuffer<Element>(
        length: length, minimumCapacity: minimumCapacity)

      _buffer._uninitializedCopy(
        _buffer.indices, target: newBuffer.firstElementAddress)
      _buffer = _Buffer(newBuffer, shiftedToStartIndex: _buffer.startIndex)
    }
    _sanityCheck(capacity >= minimumCapacity)
  }

  /// Copy the contents of the current buffer to a new unique mutable buffer.
  /// The length of the new buffer is set to `oldLength`, the capacity of the
  /// new buffer is big enough to hold 'oldLength' + 1 elements.
  @inline(never)
  internal mutating func _copyToNewBuffer(oldLength: Int) {
    let newLength = oldLength + 1
    var newBuffer = Optional(
      _forceCreateUniqueMutableBuffer(
        &_buffer, lengthForNewBuffer: oldLength, minNewCapacity: newLength))
    _arrayOutOfPlaceUpdate(
      &_buffer, &newBuffer, oldLength, 0, _IgnorePointer())
  }

  @_semantics("array.make_mutable")
  internal mutating func _makeUniqueAndReserveCapacityIfNotUnique() {
    if _slowPath(!_buffer.isMutableAndUniquelyReferenced()) {
      _copyToNewBuffer(_buffer.length)
    }
  }

  @_semantics("array.mutate_unknown")
  internal mutating func _reserveCapacityAssumingUniqueBuffer(oldLength : Int) {
    _sanityCheck(_buffer.isMutableAndUniquelyReferenced())

    if _slowPath(oldLength + 1 > _buffer.capacity) {
      _copyToNewBuffer(oldLength)
    }
  }

  @_semantics("array.mutate_unknown")
  internal mutating func _appendElementAssumeUniqueAndCapacity(
    oldLength : Int,
    newElement : Element
  ) {
    _sanityCheck(_buffer.isMutableAndUniquelyReferenced())
    _sanityCheck(_buffer.capacity >= _buffer.length + 1)

    _buffer.length = oldLength + 1
    (_buffer.firstElementAddress + oldLength).initializeMemory(newElement)
  }

  /// Append `newElement` to the ${Self}.
  ///
  /// - Complexity: Amortized ${O1}.
  public mutating func append(newElement: Element) {
    _makeUniqueAndReserveCapacityIfNotUnique()
    let oldLength = _getLength()
    _reserveCapacityAssumingUniqueBuffer(oldLength)
    _appendElementAssumeUniqueAndCapacity(oldLength, newElement: newElement)
  }

  /// Append the elements of `newElements` to `self`.
  ///
  /// - Complexity: O(*length of result*).
  public mutating func appendContentsOf<
    S : Sequence
    where
    S.Iterator.Element == Element
  >(newElements: S) {
    self += newElements
  }

  // An overload of `appendContentsOf()` that uses the += that is optimized for
  // collections.
  /// Append the elements of `newElements` to `self`.
  ///
  /// - Complexity: O(*length of result*).
  public mutating func appendContentsOf<
    C : Collection
    where
    C.Iterator.Element == Element
  >(newElements: C) {
    self += newElements
  }

  /// Remove and return the last element in O(1).
  ///
  /// - Requires: `!isEmpty`.
  public mutating func removeLast() -> Element {
    _require(length > 0, "can't removeLast from an empty ${Self}")
    let i = length
    // We don't check for overflow in `i - 1` because `i` is known to be
    // positive.
    let result = self[i &- 1]
    self.replaceSubrange((i &- 1)..<i, with: EmptyCollection())
    return result
  }

  /// Insert `newElement` at index `i`.
  ///
  /// - Requires: `i <= length`.
  ///
  /// - Complexity: O(`self.length`).
  public mutating func insert(newElement: Element, at i: Int) {
    _checkIndex(i)
    self.replaceSubrange(i..<i, with: CollectionOfOne(newElement))
  }

  /// Remove and return the element at index `i`.
  ///
  /// Invalidates all indices with respect to `self`.
  ///
  /// - Complexity: O(`self.length`).
  public mutating func removeAt(index: Int) -> Element {
    let result = self[index]
    self.replaceSubrange(index..<(index + 1), with: EmptyCollection())
    return result
  }

  /// Remove all elements.
  ///
  /// - Postcondition: `capacity == 0` iff `keepCapacity` is `false`.
  ///
  /// - Complexity: O(`self.length`).
  public mutating func removeAll(keepingCapacity keepCapacity: Bool = false) {
    if !keepCapacity {
      _buffer = _Buffer()
    }
    else {
      self.replaceSubrange(self.indices, with: EmptyCollection())
    }
  }

  //===--- algorithms -----------------------------------------------------===//

  public mutating func _withUnsafeMutableBufferPointerIfSupported<R>(
    @noescape body: (UnsafeMutablePointer<Element>, Int) throws -> R
  ) rethrows -> R? {
    return try withUnsafeMutableBufferPointer {
      (bufferPointer) -> R in
      let r = try body(bufferPointer.baseAddress, bufferPointer.length)
      return r
    }
  }

  @warn_unused_result
  public func _copyToNativeArrayBuffer() -> _ContiguousArrayBuffer<Element> {
    return _extractOrCopyToNativeArrayBuffer(self._buffer)
  }
}

extension ${Self} : _Reflectable {
  /// Returns a mirror that reflects `self`.
  @warn_unused_result
  public func _getMirror() -> _Mirror {
    return _ArrayProtocolMirror(self)
  }
}

extension ${Self} : CustomStringConvertible, CustomDebugStringConvertible {
  @warn_unused_result
  internal func _makeDescription(isDebug isDebug: Bool) -> String {
%   if Self != 'Array':
    var result = isDebug ? "${Self}([" : "["
%   else:
    // Always show sugared representation for Arrays.
    var result = "["
%   end
    var first = true
    for item in self {
      if first {
        first = false
      } else {
        result += ", "
      }
      debugPrint(item, terminator: "", toStream: &result)
    }
%   if Self != 'Array':
    result += isDebug ? "])" : "]"
%   else:
    // Always show sugared representation for Arrays.
    result += "]"
%   end
    return result
  }

  /// A textual representation of `self`.
  public var description: String {
    return _makeDescription(isDebug: false)
  }

  /// A textual representation of `self`, suitable for debugging.
  public var debugDescription: String {
    return _makeDescription(isDebug: true)
  }
}

extension ${Self} {
  @_transparent
  @warn_unused_result
  internal func _cPointerArgs() -> (AnyObject?, Builtin.RawPointer) {
    let p = _baseAddressIfContiguous
    if _fastPath(p != nil || isEmpty) {
      return (_owner, p._rawValue)
    }
    let n = _extractOrCopyToNativeArrayBuffer(self._buffer)
    return (n.owner, n.firstElementAddress._rawValue)
  }

}

extension ${Self} {
  /// Call `body(p)`, where `p` is a pointer to the `${Self}`'s
  /// contiguous storage.${contiguousCaveat}
  ///
  /// Often, the optimizer can eliminate bounds checks within an
  /// array algorithm, but when that fails, invoking the
  /// same algorithm on `body`'s argument lets you trade safety for
  /// speed.
  public func withUnsafeBufferPointer<R>(
    @noescape body: (UnsafeBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    return try _buffer.withUnsafeBufferPointer(body)
  }

  /// Call `body(p)`, where `p` is a pointer to the `${Self}`'s
  /// mutable contiguous storage.${contiguousCaveat}
  ///
  /// Often, the optimizer can eliminate bounds- and uniqueness-checks
  /// within an array algorithm, but when that fails, invoking the
  /// same algorithm on `body`'s argument lets you trade safety for
  /// speed.
  ///
  /// - Warning: Do not rely on anything about `self` (the `${Self}`
  ///   that is the target of this method) during the execution of
  ///   `body`: it may not appear to have its correct value.  Instead,
  ///   use only the `UnsafeMutableBufferPointer` argument to `body`.
  public mutating func withUnsafeMutableBufferPointer<R>(
    @noescape body: (inout UnsafeMutableBufferPointer<Element>) throws -> R
  ) rethrows -> R {
    // Ensure unique storage
    _arrayReserve(&_buffer, 0)

    // Ensure that body can't invalidate the storage or its bounds by
    // moving self into a temporary working array.
    var work = ${Self}()
    swap(&work, &self)

    // Create an UnsafeBufferPointer over work that we can pass to body
    let pointer = work._buffer.firstElementAddress
    let length = work.length
    var inoutBufferPointer = UnsafeMutableBufferPointer(
      start: pointer, length: length)

    // Put the working array back before returning.
    defer {
      _require(
        inoutBufferPointer.baseAddress == pointer &&
        inoutBufferPointer.length == length,
        "${Self} withUnsafeMutableBufferPointer: replacing the buffer is not allowed")

      swap(&work, &self)
    }

    // Invoke the body.
    return try body(&inoutBufferPointer)
  }
}
%end

internal struct _InitializeMemoryFromCollection<
  C: Collection
> : _PointerFunction {
  func call(rawMemory: UnsafeMutablePointer<C.Iterator.Element>, length: Int) {
    var p = rawMemory
    var q = newValues.startIndex
    for _ in 0..<length {
      p.initializeMemory(newValues[q])
      q = q.successor()
      p += 1
    }
    _expectEnd(q, newValues)
  }

  init(_ newValues: C) {
    self.newValues = newValues
  }

  var newValues: C
}

@inline(never)
internal func _arrayOutOfPlaceReplace<
  B : _ArrayBufferProtocol, C : Collection
  where
  C.Iterator.Element == B.Element,
  B.Index == Int
>(
  inout source: B, _ bounds: Range<Int>, _ newValues: C, _ insertLength: Int
) {
  let growth = insertLength - bounds.length
  let newLength = source.length + growth
  var newBuffer = Optional(
    _forceCreateUniqueMutableBuffer(
      &source, newLength: newLength, requiredCapacity: newLength))

  _arrayOutOfPlaceUpdate(
    &source, &newBuffer,
    bounds.startIndex - source.startIndex, insertLength,
    _InitializeMemoryFromCollection(newValues)
  )
}

/// A _debugRequire check that `i` has exactly reached the end of
/// `s`.  This test is never used to ensure memory safety; that is
/// always guaranteed by measuring `s` once and re-using that value.
internal func _expectEnd<C : Collection>(i: C.Index, _ s: C) {
  _debugRequire(
    i == s.endIndex,
    "invalid Collection: length differed in successive traversals")
}

@warn_unused_result
internal func _growArrayCapacity(capacity: Int) -> Int {
  return capacity * 2
}

% for (Self, a_Self) in arrayTypes:
extension ${Self} {
  /// Replace the elements within `bounds` with `newElements`.
  ///
  /// - Complexity: O(`subRange.length`) if `subRange.endIndex
  ///   == self.endIndex` and `newElements.isEmpty`, O(`length`) otherwise.
  @_semantics("array.mutate_unknown")
  public mutating func replaceSubrange<
    C: Collection where C.Iterator.Element == _Buffer.Element
  >(
    subRange: Range<Int>, with newElements: C
  ) {
    _require(subRange.startIndex >= self._buffer.startIndex,
      "${Self} replace: subRange start is negative")

    _require(subRange.endIndex <= self._buffer.endIndex,
      "${Self} replace: subRange extends past the end")

    let oldLength = self._buffer.length
    let eraseLength = subRange.length
    let insertLength = numericCast(newElements.length) as Int
    let growth = insertLength - eraseLength

    if self._buffer.requestUniqueMutableBackingBuffer(oldLength + growth) != nil {
      self._buffer.replace(
        subRange: subRange, with: insertLength, elementsOf: newElements)
    } else {
      _arrayOutOfPlaceReplace(&self._buffer, subRange, newElements, insertLength)
    }
  }
}

/// Append the contents of `rhs` to `lhs`.
public func += <
  Element, S : Sequence
  where
  S.Iterator.Element == Element
>(inout lhs: ${Self}<Element>, rhs: S) {
  let oldLength = lhs.length
  let capacity = lhs.capacity
  let newLength = oldLength + rhs.underestimateLength()

  if newLength > capacity {
    lhs.reserveCapacity(
      max(newLength, _growArrayCapacity(capacity)))
  }
  _arrayAppendSequence(&lhs._buffer, rhs)
}

/// Append the contents of `rhs` to `lhs`.
public func += <
  Element, C : Collection
  where
  C.Iterator.Element == Element
>(inout lhs: ${Self}<Element>, rhs: C) {
  let rhsLength = numericCast(rhs.length) as Int

  let oldLength = lhs.length
  let capacity = lhs.capacity
  let newLength = oldLength + rhsLength

  // Ensure uniqueness, mutability, and sufficient storage.  Note that
  // for consistency, we need unique lhs even if rhs is empty.
  lhs.reserveCapacity(
    newLength > capacity ?
    max(newLength, _growArrayCapacity(capacity))
    : newLength)

  (lhs._buffer.firstElementAddress + oldLength).initializeFrom(rhs)
  lhs._buffer.length = newLength
}
% end

//===--- generic helpers --------------------------------------------------===//

/// Create a unique mutable buffer that has enough capacity to hold 'newLength'
/// elements and at least 'requiredCapacity' elements. Set the length of the new
/// buffer to 'newLength'. The content of the buffer is uninitialized.
/// The formula used to compute the new buffers capacity is:
///   max(requiredCapacity, source.capacity)  if newLength <= source.capacity
///   max(requiredCapacity, _growArrayCapacity(source.capacity)) otherwise
@inline(never)
internal func _forceCreateUniqueMutableBuffer<_Buffer : _ArrayBufferProtocol>(
  inout source: _Buffer, newLength: Int, requiredCapacity: Int
) -> _ContiguousArrayBuffer<_Buffer.Element> {
  return _forceCreateUniqueMutableBufferImpl(
    &source, lengthForBuffer: newLength, minNewCapacity: newLength,
    requiredCapacity: requiredCapacity)
}

/// Create a unique mutable buffer that has enough capacity to hold
/// 'minNewCapacity' elements and set the length of the new buffer to
/// 'lengthForNewBuffer'. The content of the buffer uninitialized.
/// The formula used to compute the new buffers capacity is:
///   max(minNewCapacity, source.capacity) if minNewCapacity <= source.capacity
///   max(minNewCapacity, _growArrayCapacity(source.capacity)) otherwise
@inline(never)
internal
func _forceCreateUniqueMutableBuffer<_Buffer : _ArrayBufferProtocol>(
  inout source: _Buffer, lengthForNewBuffer: Int, minNewCapacity: Int
) -> _ContiguousArrayBuffer<_Buffer.Element> {
  return _forceCreateUniqueMutableBufferImpl(
    &source, lengthForBuffer: lengthForNewBuffer, minNewCapacity: minNewCapacity,
    requiredCapacity: minNewCapacity)
}

/// Create a unique mutable buffer that has enough capacity to hold
/// 'minNewCapacity' elements and at least 'requiredCapacity' elements and set
/// the length of the new buffer to 'lengthForBuffer'. The content of the buffer
/// uninitialized.
/// The formula used to compute the new capacity is:
///  max(requiredCapacity, source.capacity) if minNewCapacity <= source.capacity
///  max(requiredCapacity, _growArrayCapacity(source.capacity))  otherwise
internal func _forceCreateUniqueMutableBufferImpl<_Buffer : _ArrayBufferProtocol>(
  inout source: _Buffer, lengthForBuffer: Int, minNewCapacity: Int,
  requiredCapacity: Int
) -> _ContiguousArrayBuffer<_Buffer.Element> {
  _sanityCheck(lengthForBuffer >= 0)
  _sanityCheck(requiredCapacity >= lengthForBuffer)
  _sanityCheck(minNewCapacity >= lengthForBuffer)

  let minimumCapacity = max(
    requiredCapacity, minNewCapacity > source.capacity
      ? _growArrayCapacity(source.capacity) : source.capacity)

  return _ContiguousArrayBuffer(
    length: lengthForBuffer, minimumCapacity: minimumCapacity)
}

internal protocol _PointerFunction {
  typealias Element
  func call(_: UnsafeMutablePointer<Element>, length: Int)
}

/// Initialize the elements of dest by copying the first headLength
/// items from source, calling initializeNewElements on the next
/// uninitialized element, and finally by copying the last N items
/// from source into the N remaining uninitialized elements of dest.
///
/// As an optimization, may move elements out of source rather than
/// copying when it isUniquelyReferenced.
@inline(never)
internal func _arrayOutOfPlaceUpdate<
  _Buffer : _ArrayBufferProtocol, Initializer : _PointerFunction
  where Initializer.Element == _Buffer.Element,
  _Buffer.Index == Int
>(
  inout source: _Buffer,
  inout _ dest: _ContiguousArrayBuffer<_Buffer.Element>?,
  _ headLength: Int, // Length of initial source elements to copy/move
  _ newLength: Int,  // Number of new elements to insert
  _ initializeNewElements: Initializer
) {
  _sanityCheck(headLength >= 0)
  _sanityCheck(newLength >= 0)

  // Length of trailing source elements to copy/move
  let tailLength = dest!.length - headLength - newLength
  _sanityCheck(headLength + tailLength <= source.length)

  let sourceLength = source.length
  let oldLength = sourceLength - headLength - tailLength
  let destStart = dest!.firstElementAddress
  let newStart = destStart + headLength
  let newEnd = newStart + newLength

  // Check to see if we have storage we can move from
  if let backing = source.requestUniqueMutableBackingBuffer(sourceLength) {
    let sourceStart = source.firstElementAddress
    let oldStart = sourceStart + headLength

    // Destroy any items that may be lurking in a _SliceBuffer before
    // its real first element
    let backingStart = backing.firstElementAddress
    let sourceOffset = sourceStart - backingStart
    backingStart.deinitializePointee(count: sourceOffset)

    // Move the head items
    destStart.moveInitializeFrom(sourceStart, count: headLength)

    // Destroy unused source items
    oldStart.deinitializePointee(count: oldLength)

    initializeNewElements.call(newStart, length: newLength)

    // Move the tail items
    newEnd.moveInitializeFrom(oldStart + oldLength, count: tailLength)

    // Destroy any items that may be lurking in a _SliceBuffer after
    // its real last element
    let backingEnd = backingStart + backing.length
    let sourceEnd = sourceStart + sourceLength
    sourceEnd.deinitializePointee(count: backingEnd - sourceEnd)
    backing.length = 0
  }
  else {
    let headStart = source.startIndex
    let headEnd = headStart + headLength
    let newStart = source._uninitializedCopy(headStart..<headEnd,
      target: destStart)
    initializeNewElements.call(newStart, length: newLength)
    let tailStart = headEnd + oldLength
    let tailEnd = source.endIndex
    source._uninitializedCopy(tailStart..<tailEnd, target: newEnd)
  }
  source = _Buffer(dest!, shiftedToStartIndex: source.startIndex)
}

internal struct _InitializePointer<T> : _PointerFunction {
  internal func call(rawMemory: UnsafeMutablePointer<T>, length: Int) {
    _sanityCheck(length == 1)
    // FIXME: it would be better if we could find a way to move, here
    rawMemory.initializeMemory(newValue)
  }

  @_transparent
  internal init(_ newValue: T) {
    self.newValue = newValue
  }

  internal var newValue: T
}

internal struct _IgnorePointer<T> : _PointerFunction {
  internal func call(_: UnsafeMutablePointer<T>, length: Int) {
    _sanityCheck(length == 0)
  }
}

internal func _arrayReserve<
  _Buffer : _ArrayBufferProtocol where _Buffer.Index == Int
>(
  inout buffer: _Buffer, _ minimumCapacity: Int
) {
  let length = buffer.length
  let requiredCapacity = max(length, minimumCapacity)

  if _fastPath(
      buffer.requestUniqueMutableBackingBuffer(requiredCapacity) != nil) {
    return
  }

  var newBuffer = Optional(
    _forceCreateUniqueMutableBuffer(
      &buffer, newLength: length, requiredCapacity: requiredCapacity))
  _arrayOutOfPlaceUpdate(&buffer, &newBuffer, length, 0, _IgnorePointer())
}

public // SPI(Foundation)
func _extractOrCopyToNativeArrayBuffer<
  Buffer : _ArrayBufferProtocol
  where
  Buffer.Iterator.Element == Buffer.Element
>(source: Buffer)
  -> _ContiguousArrayBuffer<Buffer.Iterator.Element>
{
  if let n = source.requestNativeBuffer() {
    return n
  }
  return _copyCollectionToNativeArrayBuffer(source)
}

/// Append items from `newItems` to `buffer`.
internal func _arrayAppendSequence<
  Buffer : _ArrayBufferProtocol,
  S : Sequence
  where
  S.Iterator.Element == Buffer.Element,
  Buffer.Index == Int
>(
  inout buffer: Buffer, _ newItems: S
) {
  var stream = newItems.iterator()
  var nextItem = stream.next()

  if nextItem == nil {
    return
  }

  // This will force uniqueness
  var length = buffer.length
  _arrayReserve(&buffer, length + 1)
  while true {
    let capacity = buffer.capacity
    let base = buffer.firstElementAddress

    while (nextItem != nil) && length < capacity {
      (base + length++).initializeMemory(nextItem!)
      nextItem = stream.next()
    }
    buffer.length = length
    if nextItem == nil {
      return
    }
    _arrayReserve(&buffer, _growArrayCapacity(capacity))
  }
}

% for (Self, a_Self) in arrayTypes:
// NOTE: The '==' and '!=' below only handles array types
// that are the same, e.g. Array<Int> and Array<Int>, not
// ArraySlice<Int> and Array<Int>.

/// Returns true iff `lhs` and `rhs` contain equal elements in the same
/// order.
@warn_unused_result
public func == <Element : Equatable>(
  lhs: ${Self}<Element>, rhs: ${Self}<Element>
) -> Bool {
  let lhsLength = lhs.length
  if lhsLength != rhs.length {
    return false
  }

  // Test referential equality.
  if lhsLength == 0 || lhs._buffer.identity == rhs._buffer.identity {
    return true
  }

  var streamLHS = lhs.iterator()
  var streamRHS = rhs.iterator()

  var nextLHS = streamLHS.next()
  while nextLHS != nil {
    let nextRHS = streamRHS.next()
    if nextLHS != nextRHS {
      return false
    }
    nextLHS = streamLHS.next()
  }

  return true
}

/// Returns true iff `lhs` and `rhs` do not contain equal elements in
/// the same order.
@warn_unused_result
public func != <Element : Equatable>(
  lhs: ${Self}<Element>, rhs: ${Self}<Element>
) -> Bool {
  return !(lhs == rhs)
}
%end

#if _runtime(_ObjC)
/// Returns an `Array<Base>` containing the same elements as `a` in
/// O(1).
///
/// - Requires: `Base` is a base class or base `@objc` protocol (such
///   as `AnyObject`) of `Derived`.
@warn_unused_result
public func _arrayUpCast<Derived, Base>(a: Array<Derived>) -> Array<Base> {
  // FIXME: Dynamic casting is currently not possible without the objc runtime:
  // rdar://problem/18801510
  return Array(a._buffer.castToBufferOf(Base.self))
}
#endif

#if _runtime(_ObjC)
extension Array {
  /// Try to downcast the source `NSArray` as our native buffer type.
  /// If it succeeds, create a new `Array` around it and return that.
  /// Return `nil` otherwise.
  // Note: this function exists here so that Foundation doesn't have
  // to know Array's implementation details.
  @warn_unused_result
  public static func _bridgeFromObjectiveCAdoptingNativeStorage(
    source: AnyObject
  ) -> Array? {
    if let deferred = source as? _SwiftDeferredNSArray {
      if let nativeStorage =
        deferred._nativeStorage as? _ContiguousArrayStorage<Element> {
        return Array(_ContiguousArrayBuffer(nativeStorage))
      }
    }
    return nil
  }

  /// Private initializer used for bridging.
  ///
  /// Only use this initializer when both conditions are true:
  ///
  /// * it is statically known that the given `NSArray` is immutable;
  /// * `Element` is bridged verbatim to Objective-C (i.e.,
  ///   is a reference type).
  public init(_immutableCocoaArray: _NSArrayCore) {
    self = Array(_ArrayBuffer(nsArray: _immutableCocoaArray))
  }
}
#endif

extension Array {
  /// If `!self.isEmpty`, remove the last element and return it, otherwise
  /// return `nil`.
  ///
  /// - Complexity: O(`self.length`) if the array is bridged,
  ///   otherwise O(1).
  public mutating func popLast() -> Element? {
    guard !isEmpty else { return nil }
    return removeLast()
  }
}

extension ContiguousArray {
  /// If `!self.isEmpty`, remove the last element and return it, otherwise
  /// return `nil`.
  ///
  /// - Complexity: O(1)
  public mutating func popLast() -> Element? {
    guard !isEmpty else { return nil }
    return removeLast()
  }
}

// ${'Local Variables'}:
// eval: (read-only-mode 1)
// End:
